# ОТДЕЛЬНО ПРО ООП
Класс - это программный код, который задает атрибуты данных и метода для объекта определенного типа
Объект — это экземпляр класса, или его копия, которая находится в памяти компьютера. Например, когда вы создаёте переменную типа String и присваиваете ей значение «Строка», то в памяти создаётся экземпляр класса String.
Экзэмпляр класса - копия класса, которая создается на его основе. Класс можно сравнить с чертежом, на основе которого создаются экзэмпляры
Инкапсуляция — процесс разделения элементов абстракций, определяющих её структуру (данные) и поведение (методы); инкапсуляция предназначена для изоляции контрактных обязательств абстракции (протокол/интерфейс) от их реализации
Публичный метод - такой метод, доступ к которому можно получить откуда угодно - извне определенного класса, из объекта определенного класса, из наследников. А теперь своими словами: публичный - тот, чей результат можно махнуть за приделами класса
Приватный метод - такой метод, доступ к которому можно получить только из того же класса. Тот, чей результат нельзя махнуть за приделами класса
Инициализация — приведение цифрового устройства или его программы в состояние готовности к использованию.
когда программа работает, она может создать столько объектов определенного типа, сколько понадобиться
Экзэмпляр класса - каждый объект, который создается на основе класса
в классах через деф теперьь не функции пишутся, а методы 
атрибуты данных - значения
переменные называются атрибутами
функции называются методами
не уверенн, что всегда, но переменная self требуется в каждом методе класса
import random

class Coin:
```python
    import random
    #  метод __init__ инициализирует, то есть переводит в состояние готовности
    # атрибут данных sideup значением  'орел'

    def __init__(self):
        self.__sideup = 'Орел'

    def toss(self):
        if random.randint(0,1) == 0:
            self.__sideup = 'Орел'
        else:
            self.__sideup = 'Решка'


    def get_sideup(self):
        return self.__sideup

def main():
    # созддать объект на основе класса coin
    my_coin = Coin()
    # показать обращенную вверх сторону монетки
    print('Эта сторона обращена вверх:', my_coin.get_sideup())
    # подбросить монетку вверх
    print('подбросил монетку 10 раз')
    for count in range(10):
        my_coin.toss()
        print(my_coin.get_sideup())


if __name__ == '__main__':
    main()
```
в строке 36 происходит хуйня, которая создает в оперативной памяти объект на основе класса Coin
далее исполняется метод __init__() этого же класса и параметру self автоматом назначается объект, который только что былл создан
В результате атрибуту sideup этого объекта присваевается строковой литерал 'орел'
после этого присваевается только что созданный объект Coin переменной my_coin
два подчеркивания перед sideup - означает, что атрибут(значение) не мазнуть за пределами класса

а еще нужно делать табличку, в которой будет то, какие методы надо будет сделать и какие атрибуты данных нужны 
 она должна выглядить так: имя класса
						   атрибуты данных
						   методы
такие диаграммы называются диаграммами UML можно погуглить, если что

ГЛАВА 12(наследование)
наследование позволяет новому классу расширять существующий класс. НОвой класс наследует ввсе методы из сущекствующего 
НАДКСЛАСС - это родовой класс
ПОДКЛАСС - это конкретезированный класс. Проверить унаследован ли класс от другого класса, можно с помощью
	функции issubckass(подкласс, класс)
ПОдкласс наследует атрибуты и методы надклассабез необходимости переписывать его атрибуты и методы
при наследовании короче, можно писать super() перед переменными, которые так же есть в родительском классе
не совсем понял, для чего, но вроде это круто

МЕТОД  isinstance(объект, класс)
короче, эта хуйня создана, чтобы проверять является ли объект экзжмпляром класса или его подклассов, если нет, то там через елс можно сказать, что чел то даун


КАРОЧЕ
```python
class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def diameter(self):
        return 2 * self.radius

    @diameter.setter
    def diameter(self, value):
        self.radius = value / 2
```
`@property` - дает возможность образаться к мметоду, как к атрибуту. То есть можно спокойно вызывать как атрбут
`@diameter.setter` - эта штука дает возможность менять значение радиуса
circle = Circle(5)
print(circle.diameter)  # 10
circle.diameter = 20    # Изменяем диаметр
print(circle.radius)    # Радиус пересчитан: 10

## ИМЕНОВАННЫЕ КОРТЕЖЫ:
	это подкласс кортежей, с помощью которых можем получить доступ к значением по имени (используя конструкцию .имя)
	и позиции (используя конструкцию  [смещение])
	from collections import namedtuple

	Duck = namedtuple('Duck', 'bill tail')
	duck = Duck('Оранжевый', 'длинный')
	print(duck[-1])
	это короче пример, как можно создать объект с данными без класса. Это тема создана с помощью кортежа
	from collections import namedtuple

	Duck = namedtuple('Duck', 'bill tail')
	parts = {'bill': 'Оранжевый', 'tail': 'длинный типчик'}
	duck = Duck(**parts)
	print(duck[-1])
	тип тот же самый пример, но со словарем
### Объяснение про `**parts`

Когда используется запись `**parts`, это называется **распаковкой словаря**. Она нужна для передачи значений из словаря как именованных аргументов функции или конструктора. 

В случае с `Duck(**parts)`:
- У нас есть словарь `parts`, содержащий ключи `'bill'` и `'tail'` с соответствующими значениями.
- `Duck` — это `namedtuple`, который ожидает аргументы с именами `'bill'` и `'tail'`.
- Синтаксис `**parts` "распаковывает" словарь, передавая его ключи как имена аргументов, а их значения как значения аргументов.

**Без `**` это не сработает, потому что словарь `parts` будет передан как один аргумент, а не как два отдельных.**

### Пример для понимания
```python
# Без **:
duck = Duck(parts)  # Ошибка! Duck ожидает два аргумента (bill и tail).

# С **:
duck = Duck(**parts)  # Успешно! bill='Оранжевый', tail='длинный типчик'
```

### Что такое `*` и `**` в Python

#### `*` — Распаковка последовательностей (list, tuple)
`*` используется для распаковки элементов последовательности, чтобы передать их как **позиционные аргументы**.

Пример:
```python
def add(a, b):
    return a + b

args = [3, 5]
print(add(*args))  # Распаковка списка в два аргумента add(3, 5)
# Вывод: 8
```

#### `**` — Распаковка словарей
`**` используется для передачи **именованных аргументов** из словаря.

Пример:
```python
def greet(name, age):
    return f"Привет, {name}! Тебе {age} лет."

kwargs = {'name': 'Никита', 'age': 19}
print(greet(**kwargs))  # greet(name='Никита', age=19)
# Вывод: Привет, Никита! Тебе 19 лет.
```

### Почему это нужно?

1. **Удобство**: Если у вас уже есть данные в виде последовательности (`list`, `tuple`) или словаря, вы можете передать их напрямую.
2. **Гибкость**: Вы можете динамически создавать аргументы для функций.
3. **Читаемость**: Распаковка делает код лаконичным и понятным.

### Если не использовать `*` и `**`
Без `*` и `**` нужно вручную передавать аргументы. Это неудобно, особенно если их много или они динамические.

Пример:
```python
kwargs = {'name': 'Никита', 'age': 19}

# Без **:
print(greet(name=kwargs['name'], age=kwargs['age']))

# С **:
print(greet(**kwargs))
```

### Подведем итог
`*` и `**` нужны для распаковки:
- `*` — для позиционных аргументов (list, tuple).
- `**` — для именованных аргументов (dict).

КЛАССЫ ДАННЫХ
```python
	class TennyClass:
        def __init__(self, name):
            self.name = name

	tenny = TennyClass('хуй')
	print(tenny.name) 
	# вот этот пример создан обычно, без классов данных
	
	from dataclasses import dataclass


	@dataclass
	class TennyClass:
			name: str


	tenny = TennyClass('хуй')
	print(tenny.name)
	# а тут реализованно все то же самое,но уже с дата классом 
	
	
	from dataclasses import dataclass


	@dataclass
	class TennyClass:
		name: str
		surname: str
		yers: int = 0


	tenny = TennyClass('хуй', 'ХУЕВИЧ', 90)
	print(tenny.yers)
```