# Первая книга по пайтону


## команды интересные:
	pass - используется для того, чтобы оставить функцию пустой, чтобы потом начать ее заполнять, а код работал без ошибок,
	так же можно использовать в любом месте в качестве заполнителя
		например: def step3():
					pass
	global - используется, если хочешь, чтобы переменная одной функции распростарнялась на другие
	randint() - выводит случайное целое число из указанного в скобках диапозона
	random() - ниче в скобки не писать, она всегда будет выводит число от 0.0 до 1.0 не вкл
	uniform() - возвращает число с плавающей точкой, но позволяет задать диапозон значений
	randrange() - вроде тоже самое, что и randint, только еще можно шаг задать через запятую
	choice(спиксок, k=n) -- n - скика элементов надо вывести. Рандомно выводит n элементов из спикска, но может иногда выводит случайно и одинаковые элементы
	sample(список, k = n) - тоже самое, что и choice, только всегда будет выводит именно уникальные элементы из списка

```
Отдельно для строк, потому что я их скипнул:
	.lower() - для того, чтобы все буквы сделать не капсом


Функция - это группа интструкций, которая существует внутри программы с целью выполнения определенной задачи
глобальная константа - это глобальное имя, ссылающееся на значение, которое нельзя изменить
модуль - это файл, который содержит программный код python. Большие программы проще отлаживать и поддерживать, когда они подразделоенны на модули
метод  - это функция, которая пренадлежит объекту и выполняет некоторую операцию с использованием этого объекта
кортеж - неизменяемая последовательность, элементы заключаются в скобках. Кортежи так же поддерживают индексацию как и списки
	list() - может преобразовать кортеж в список
```
## ФАЙЛЫ:
	файловая_переменная = open(file_name, режим)
	режимы:
		1r - открыть файл только для чтения. Файл не может быть изменен, в него нельзя записать
		2w - Открыть файл для записи. Если файл уже существует, то стереть его сожержимое. Если файла не существует, то создать его
		3a - Открыть файл, в который будет выполнена запись. Все записываемые в файл данные будут добавлены в его конец. Если файл не существует, то создать его
	методы:
		write() - название говорит само за себя
		writelines() - может записать список в фалл, но этот список будет записан без пробелов и переносов(лучше через for добавлять из списка элементы)
		read() - название говорит само за себя(считывает весь файл)
		readline() - считывает строку
		readlines() - возвращает сожержимое файла, как список строковых значений
		rstrip() - удаляет определенные символы с конца строки
		для них надо import os:
			remove(файл) - удаляет файл
			rename('файл который переименовать', 'новое название') - переименовывает

## Исключение - это ошибка которая происходит во время работы программы, приводяая к ее внезапному останову программы
	инструкции:
		try
		except
		else
		finally - вот жто интересная какая-то хуйня. Будет исполнять блок инструкций, которые туды записаны не в зависимости от того, попал ли код в except(то есть ошибку)

## Списки:
	list(range(5)) - выведет список [0,1...]
	list - возвращает список
	[0] * 5 = [0,0,0,0,0]
	Методы:
		append(значение) - добвляет значение в конец списка
		index(знвчение) - возвращает индекс значения
		insert(индекс, значение) - добавляет значение на тот индекс, который был указан
		sort() - сортирует список в возврастающем порядке
		sorted() - возращает отсортированую копию списка
		remove(значение) - удаляет значение из списка, если такое есть, если такого нет, то ошибка вылетает
		reverse() - в обратном порядке записывает
		extend(список) - можно так списки объединять
		pop(номер элемента в списке) - возвращает элемент из списка и удаляет этот же элемент в самом списке
		clear() - чистит список нахуй
		count() - считает скок раз элемент появляется в списке
		join() - сипсок в строку превращает
		copy() - копирует список в новую переменную 
		list() - может копировать список в новую переменную
		[:] - то же самое делает, но все эти способы лишь создают новые переменные, но ссылки будут на те же объекты
		соответственно будут меняться все списки
		deepcopy() - делает тоже самое, но это новый объект
		как нормальные ребята списки создают:
			[number for number in range(1,6)]
			[number-1 for number in range(1,6)]
			[number for number in range(1,6) if number % 2 == 1]
	Инструкция del:
		my_list = [1,2,3,4,5]
		del my_list[2]
		print(my_list)
		[1, 2, 4, 5]
		
## МОДУЛЬ pyplot:
	grid(True) - выволит сетку
	plot(аргументы) - чертит график
	xlabel, ylabel - подписывают оси
	title - подписывает заголовок
	show() - сам график выводит
	xlim() - границы расставляет
	ylim() - границы расставляет
	xticks(), ytricks() - называть мона каждую метку
	marker='o' - можно добваить так точку кргулую
	пример кода:
		import matplotlib.pyplot as plt

		x = [1, 2, 3, 4]
		y = [10, 20, 25, 30]

		plt.xlim(xmin=0, xmax=10)
		plt.ylim(ymin=0, ymax=100)
		plt.plot(x, y, marker='0')
		plt.xticks([1,2,3,4],
				   ['бейсбол','баскетбол','волейбол','пейнтбол'])
		plt.xlabel('x - ось')
		plt.ylabel('y - ось')
		plt.title('Простой график')
		plt.grid(True)
		plt.show()
	так же можно посторить гистограмму:
		надо просто использовать функцию 'bar' вместо plot, третий аргумент используется, чтобы сдлеать длинну столбика


## СЛОВАРИ:
	словарь сощдается путем заключения его элементов в фигурные скобки. 
	Элемент состоит из ключа потом двоеточия, потом идет значение
	Отделяются элементы запятыми
	ключи - немутируемые объекты
	а связанные с ними объекты могут быть любого типа
	УДАЛЕНИЕ ЭЛЕМЕНТОВ ИЗ СЛОВАРЯ:
		del dictionary_name[dictionary_key]
	получать количество элементов в словаре можно через функцию len
	Добавление в словарь новых элементов:
		dictionary_name[new_dictionary_key] = значение
	так же для созжания пустого словаря можнор воспользоваться встроеным методом dict()
		переменная название словаря = dict()
	словарные методы:
		clear() - очищает содержимое словаря
		get(ключ, значение по умолчанию) - получает значение связанное с заданным ключом. Если ключ не найден, этот метод не вызывает исключение. Вместо этого он возвразает значение по умолчанию		
		items() - Возвращает все ключи в словаре и связанные с ними значения в виде последовательности кортежей
		keys() - возвращает все ключи в словаре в виде последовательности кортежей
		pop(ключ, значение по умолчанию) - возвращает из словаря значение, связанное с заданным ключом и удаляет эту пару "ключ : значение". Если ключ не найден, этот метод возвращает значение по умолчанию 
		popitem() -(см стр 484) Возвращает в виде кортежа последнюю добавленную в словарь пару "ключ : значение". Этот метод также удаляет пару "ключ : значение"
		values() - Возвращает все значения значения из словаря в виде последовательностей кортежей
		update(словарь) - добавляет в старый словарь в словарь
		copy() - копирует словарь, но это указатели на 1 и те же значения
		deepcopy() - копирует словарь, но это уже абсолютно новый словарь
	пример кода:
		def main():
			try:
				phonebook = {'Kris':('555-222', '444-222'), 'Кэти':'222222', 'абоба':'222-333'}
				for key in phonebook:
					print(key, phonebook[key])
			except KeyError:
				print('ты дурачек, ебаный, пиши внимательнее')

		if __name__ == '__main__':
			main()
			480
	ВКЛЮЧЕНИЕ В СЛОВАРЬ:
		numbers = [1, 2, 3, 4]
		squares = {item:item**2 for item in numbers}

		print(squares)
	ОБЪЕДИНЕНИЕ СЛОВАРЕЙ:
		first = {'a': 'agony', 'b': 'bliss'}
		second = {'b': 'bagels', 'c': 'candy'}
		{**first **second}
		#{'a': 'agony', 'b': 'bagels', 'c': 'candy'}
		
## МНОЖЕСТВА:
	множество, как словарь, у которого отброшенны значения. То есть, если вам нужна инфа об объекте, то вам нужен словарь, иначе - множество
	множество - объект-контейнер уникальных значений, который работает как математическое множжество
	чтобы создать множество, надо использовать встроенную команду set()
	.add - добавление элементов
	.update() - добавляет сразу пачку элементов(но они должны находится в списке или т.д.)(см страницу 501)
	.remove() - удаление элементов
	.discard() - удаление элементов(разница в том, что он не выдаст ошибку в отличии от .remove)
	.clear() - нахуй все элементы удаляет
	.len() - длину считает
	так же множества мжожно объединять:
		set1 = set([1, 2, 3, 4])
		set2 = set([5, 6, 7, 8])
		set3 = set1.union(set2)
		or set3 = set1 | set2
	пересечение мнодеств:
		set1.intersection(set2)
		or set1 & set2
	разность множеств(то есть возвращает все элементы множества не входящего в другое множество):
		set1.difference(set2) (возвращает элементы первого множество, не войдящие во второе множество)
		or set1 - set2
	симетричная разность множеств(то есть можно захуярить множество в которое вхожят элементы множеств, которые не повторяются)
		set1.symmetric_difference(set2)
		or set1 ^ set2

## CЕРИАЛИЗАЦИЯ ОБЪЕКТОВ:
	ну короче переводы в какие-то байты, биты хуй пойми че. Сделано, для того, чтобы сохранить в файл содержимое сложного объекта, типо словаря, множества
	открывать файл надо со строковым литералом wb
	
```
класс - это вообще план по сути
типо класс - это как проект дома(то есть не объект) по нему можно строить дома идентичные
класс - описание свойств 


Полезные комбинации клавиш в пайчарме(прям сладко): https://habr.com/ru/articles/718980/
```