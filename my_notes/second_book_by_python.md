# Конспект по моей второй, прочитанной книге
```
Этот текстовый документ создан, чтобы подчеркнуть какие-то важные моменты, которые я понял только к этому моменту
и дополнить знания, полученные из второй книги


списки, словари, множества, байты и массивы байтов изменяемые типы данных, остальные нет. То есть
если один список приравнять к другому и изменить один из, то изменяться оба 
divmod(числитель, знаменатель) - мы получим кортеж из 2 элементов, где будет целое число при делении и остаток
\ - после жтого символа можно спокойно рподолжать писать код на следующей строке, и пайтон будет считывать это
все за 1 строку
если писать в круглых, квадратных или фигурных скобках, то можно переносить спокойно (без специальных символов)
и пайтон на это даловаться не будет
забавно, что я об этом вроде даже не догадывался, но
можно проверять, если переменная 1 буква, например, а другая - целое слово, то можно проверить - ечть ли эта буква
в этом слова через in констрк: переменная буква in переменная слова
.split('по чему разделять') - разделяет строку по символу, который указан в скобках и создает список из элементов
разделенных. Если ничего не указывать,то будет разделять по пробелам и табуляциям
.join - противоположность split (объеденяет список строк в одну строку)
перед джоин строка, по которой будут разделены элементы. в скобках список, кортеж... из котоорого будут объеденены
все элементы в 1 строку
replace - все понятно
strip() - удаляет симоволы табуляцияции, пробелы, переносы во всей строке
lstrip() - слева
rstrip() - справа
startswith() - можно проверить, начинается ли строка с того, что написано в скобках
endswith() - заканчивается ли тем, что в скобках написано (возвращает TRUE or FALSE)
cound() - счет
capitalize - запишет строку с большой буквы
title - каждое слово в строке с большой буквы будет написано
upper - вся строка капсом 
lower -  наоборот
swappcase - меняет регистр, который на данный момент у буквы
center() - выравнивание
ljust() - выравнивание по левому краю
rjust() - по правому


while - else - конструкция такая работает после того, как весь цикл выполнился, то тогда и else срабатывает
for - else - тоже самое
создаются кортежы с помощью. Короче можно числа через запитую или/и буквы вписывать
кортежы позволяют присваивать значения сразу нескольким переменным
например:
	tup = (1, 2, 3)
	a, b, c = tup
	
с помощью tuple() - можно создавать кортежы из других объектов
с помощью + можно объединять кортежы
```
## списки:
	списки можно создавать из других объектов с помощью list()
	чтобы изменить порядок, используем reverse()
```
хз, может пригодиться знание, что в функцию мы передаем аргументы, а внутри функции мы пользуемся параметрами
не забывать, что можно в функции параметры изначально по умолчанию указывать
def prin_k(r1, r2, *srgs):
    print('я твой рот ебал', r1)
    print('и его я тоже пер', r2)
    print('и все это остальное я тоже рот ебал', srgs)

n = prin_k('Никита', 'Иван', 'уебок', 'сира', 'кира')
print(n)
все остальные перейдут в srgs. И srgs будет являться кортежем 
НАВЕРНОЕ САМЫЙ БЫСТРЫЙ СПОСОБ СОЗДАНИЯ СЛОВАРЯ:
	def print_keywords(**kwrds):
		print('keywords arguments:', kwrds)

	print_keywords(name='Никита', age='18', familia='Телегин')
```
```
можно вместо того, чтобы функцию мелкую прописывать, можно lamda прописать внутри существующей
например:
	stairs =  ['привет', 'убланы', 'гнилозубые', 'проебали']

	def summa(stairs, func):
		for word in stairs:
			print(func(word))

	summa(stairs, lambda word: word.upper() + '!')

функция-генератор
хз, какая-то функция, которая при вызове ее пишет, что это генератор. И можно перебрать поочереди значения
def my_range(first = 0, last = 10, step = 1):
    number = first
    while number < last:
        yield number
        number += step


ranger = my_range(1,7)

for x in ranger:
    print(x)
	
еще важный момент, что генератор сработает этот только 1 разделенных
```
## ВКЛЮЧЕНИЕ ГЕНЕРАТОРОВ:
``` 
genobj = (pair for pair in zip(['a', 'b'], ['1','2'])) - это короче генератор
for thing in genobj:
	print(thing)
```
	
	
## доплонение функции в другой функции без декоратора:
```
def dicoration1():
    print('я еблан я еблан')


def dicoration2(func):
    def wrapper():
        print('не хотят дружить со мной')
        func()
        print('не хотят дружить со мной')
    return wrapper


if __name__ == '__main__':
    aboba = dicoration2(dicoration1)
    aboba()

isinstance позволяет проверять типы объектов (например, чтобы отличать списки от других элементов).
yield делает функцию генератором, который возвращает элементы по одному за раз (удобно для работы с большими данными или вложенными структурами).
```
## КОДИРОВАНИЕ/ДЕКОДИРОВАНИЕ
```
ВОТ ТУТ МЫ СОЗДАЛИ И ЗАКОДИРОВАЛИ СТРОКУ В БАЙТЫ ВРОДЕ
	place = 'caf\u00e9'
	place_bytes = place.encode('utf-8')
ТУТ МЫ ДЕКОДИРОВАЛИ 
	place2 = place_bytes.decode('utf-8')
```
```
АХУЙ, ПЕРВОЕ УПОМИНАНИЕ html
Еще 1 способ выполнять преобразования в Uniclode и обратно - с помощью символов символов-мнемоников HTML
html.escape() — преобразует специальные символы в их HTML-сущности(типо кодирует).
html.unescape() — преобразует HTML-сущности в соответствующие символы(типо декодирует).
```

# РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
```
match() и compile() — это функции из модуля re в Python, который используется для работы с регулярными выражениями. Они помогают искать и обрабатывать текстовые данные на основе шаблонов. Разберём их по порядку.

1. re.match()
Функция match() пытается найти соответствие шаблону только в начале строки. Если начало строки 
соответствует шаблону, она возвращает объект Match. Если нет — возвращает None.
import re
re.match(pattern, string, flags=0)
pattern — регулярное выражение (шаблон поиска).
string — строка, которую нужно проверить.
flags — дополнительные параметры (например, игнорирование регистра).
ПРИМЕР
import re

# Ищем слово "Hello" в начале строки
result = re.match(r"Hello", "Hello, world!")
if result:
    print("Найдено:", result.group())  # "Hello"
else:
    print("Совпадений нет.")


Функция compile() используется для создания "скомпилированного" объекта регулярного выражения. 
Это полезно, если вы планируете многократно использовать одно и то же регулярное выражение — так 
код будет быстрее и чище.

import re
pattern = re.compile(pattern, flags=0)

pattern — шаблон регулярного выражения.
flags — дополнительные параметры.
После компиляции можно использовать методы объекта, такие как:
match() — ищет совпадение в начале строки.
search() — ищет первое совпадение в строке.
findall() — возвращает все совпадения.
sub() — заменяет найденные совпадения.

ПРИМЕР
	import re

	# Компиляция шаблона
	pattern = re.compile(r"\d+")  # Шаблон для поиска чисел

	# Применение метода match
	result = pattern.match("123abc")
	if result:
		print("Найдено:", result.group())  # "123"

	# Применение метода search
	result = pattern.search("abc123")
	if result:
		print("Найдено:", result.group())  # "123"

	# Применение метода findall
	numbers = pattern.findall("abc123def456")
	print(numbers)  # ['123', '456']

# Без r
print("Hello\nWorld")  
# Результат:
# Hello
# World (перенос строки)

# С r
print(r"Hello\nWorld")  
# Результат:
# Hello\nWorld (символ \n интерпретируется как текст)

search() - вощращает первое совпадение, если такое имеется
findall() - возращает список всех непересекающихся совпадений, если таковые имеются
split() - разбивает источник на совпадения с шаблоном и возращает список всех фрагментов строки
sub() - принимает аргумент, который надо будет заменять, потом на что менять, потом строку, в которой менять
import re

sours = 'Гени лидер миллиантроп фембой хуесос'

m = re.findall('л', sours)
if m:
    print(m)  # ['л', 'л', 'л']
еще можно искать в сваязке с
	* - обозначает ноль или более символов
	. - обозначает любой отдельный символ
	.* - любое кол-во символов 
	? - включение предыдущего (0 или 1 символ)
	.? - значит это делает, что может быть после и или не быть сиволов
```
# шаблон	совпадения
    \d		цифровой символ
    \D		нецифровой символ
    \w		буквенный или цифровой символ или знак подчеркивания
    \W		любоф символ кроме буквенный или цифровой символ или знак подчеркивания
    \s		пробельный символ
    \S		непробельный символ
    \b 		граница слова
    \B		не граница слова


# ПРИМЕР ПРИМЕНЕНИЯ
    import string
    import re
    
    printable = string.printable
    
    my_list = re.findall(r'\d', printable)
    
    print(my_list)


# ШАБЛОНЫ ЕЩЕ 1
```
ШАБЛОН			СОВПАДЕНИЯ
abc 			Буквосочетания abc
(expr)			expr
expr1|expr2		expr1 или expr2
. 				Любой символ кроме \n
^				начало строки источника
$				конец строки источника
prev? 			ноль или 1 включение prev
prev*			ноль или больше включений prev, максимально кол-во
prev*?			ноль или больше включений prev, минимальное кол-во
prev+			одно или больше включений prev, максимальное кол-во
prev+?			одно или больше включений prev, минимальное кол-во
prev{m}			m последовательных включений prev
prev{m,n}		от m до n последовательных включений prev, максимальное кол-во
prev{m,n}?		от m до n последовательных включений prev, минимальное кол-во
[abc]			a, или, b, или c (аналогично a|b|c)
[^abc]			Не (a, или b, или c)
prev(?=next)	prev, если за ним следует next 
prev(?!next)	prev, если за ним не следует next
(?<=prev)next	next, если перед ним находится prev
(?<!prev)next	next, если перед ним не находится prev

prev (previous) — это шаблон, который должен находиться перед чем-то.
next (next) — это шаблон, который должен находиться после чего-то.
expr (expression) — это произвольное регулярное выражение (может быть сложным или простым).
```
# БИНАРНЫЕ ДАННЫЕ
    bytes неищменяем, как кортед байтов
    bytearray изменяем, как список байтов
    
    blist = [1, 2, 3, 255]
    the_bytes = bytes(blist)
    the_byte_array = bytearray(blist)
    print(the_bytes) # b'\x01\x02\x03\xff'
    print(the_byte_array) # bytearray(b'\x01\x02\x03\xff')
    the_byte_array[1] = 127
    print(the_byte_array) # bytearray(b'\x01\x7f\x03\xff')
    
    .pack('указывает, как интерпретировать входные последовательности байтов и преобразовать их', битовая переменная получается) - запоковать. То есть перести в байты
    .unpack('вроде то же, но наоборот', либо переменная, либо числа ...) - расспоковать

```
СПЕЦИФИКАТОРЫ ПОРЯДКА БАЙТОВ
| Спецификатор | Описание                  |
|--------------|---------------------------|
|     >        | Big-endian (старший байт первым) |
|     <        | Little-endian (младший байт первым) |


СПЕЦИФИКАТОРЫ ФОРМАТА
| Спецификатор | Описание                           | Количество байтов |
|--------------|------------------------------------|-------------------|
| x            | Пропустить байт					| 1					|
| b            | знаковый байт					    | 1                 |
| B            | Беззнаковый байт		            | 1                 |
| ?            | Логическое значение (bool)         | 1                 |
| h            | Знаковое короткое целое число      | 2                 |
| H            | Беззнаковое короткое целое число   | 2                 |
| i            | Знаковое целое число (int)         | 4                 |
| I            | БеззнаковоеЦелое число             | 4                 |
| l            | Знаковое длинное целое число       | 4                 |
| L            | Беззнаковое длинное целое число    | 4                 |
| q            | Целое число (long long)            | 8                 |
| Q            | Беззнаково очень длинное целое числ| 8                 |
| f            | Число с плавающей точкой (float)   | 4                 |
| p            | счетчик и символы 1+ кол-во        | 1 + кол-во        |
| s            | символы                            | символы           |
| d            | Число с плавающей точкой двойной   | 8                 |
												точности
												
КОРОЧЕ, ЕСЛИ НАДО БУДЕТ, ТО МОЭНО ПОСМОТРЕТЬ МОДУЛЬ binascii
```



# КАЛЕНДАРЬ И ЧАСЫ
	МОДУЛЬ datetime
		date - для годов, месяцев и дней
		time - для часов, минут, секунд и долей секунды
		datetime - для даты и времени одновременно
		timedelta - для интервалов даты и/или времени
		
		
		мы можем создать объект date, указав год, месяц и день
			halloween = date(2025, 10, 31)
			print(halloween)  #datetime.date(2025,10,31)
			print(halloween.day) # 31 
			print(halloween.month) #10
			hal.isoformat() - # '2025-10-31'
			
	МОДУЛЬ time
		time.ctime(now) - # 'Wed Feb  5 19:29:38 2025'
		now = time.time() # 1738773026.7954073
		time.ctime(now) # 'Wed Feb  5 19:30:26 2025'
		
		рассмотрим пример работы функции strftime(), предоставленной модулем  time.
		Она преобразует объект struct_time в строку. Сначала мы определим строку формата fmt
		и потом будем ее использовать
		fmt = "It's %A, %B, %d, %Y, local time %I:%M:%S:%p"
		t = time.localtime() # time.struct_time(tm_year=2025, tm_mon=2, tm_mday=5, tm_hour=19, tm_min=41, tm_sec=15, tm_wday=2, tm_yday=36, tm_isdst=0)
		print(time.strftime(fmt, t)) # It's Wednesday, February, 05, 2025, local time 07:45:03:PM
			
			
			
	
# ФАЙЛЫ И КАТАЛОГИ
	with open('examp.txt', 'wt') as f:
		poem = '''зачем же я опять
		занимюсь этой хуетой, я не пойму
		я не пойму баля'''
		print(poem, file=f, sep = ' ', end = ' ') # можно так в файл текст записывать
		# sep (разделитель, по умолчанию это пробел ' ')
		# end (символ конца файла, по умолчанию это симвлон новой строки '\n')
		f.write(poem) # или так
		
		
		with open('examp.txt', 'wt', encoding='utf-8') as f:
			poem = 'зачем же я опять\n' + \
			'занимюсь этой хуетой, я не пойму\n' + \
			'я не пойму баля'
			print(poem, file=f, sep='|', end='|')
			
			
	ВОТ ТАК ТЕКСТ БЛОКАМИ ЗАПИСЫВАЕТСЯ
	так писать стоит тогда, когда капец, какие большие тексты, чтобы в памяти за раз много места
	не занимали, ну или, когда  по сети данные частями, что бы передавать, короче лучше так всегда
	записывать на всякий случай. Нечего плохого не будет от этого, а ресурсы сэкономятся 
	size = len(poem)
    offset = 0
    chunk = 100
    while True:
        if offset > size:
            break
        f.write(poem[offset:offset+chunk])
        offset += chunk

	ВОТ ТАК МОЖНО ЗАБИРАТЬ ИЗ ФАЙЛА ПОЛНОСТЬЮ:
		with open('examp.txt', 'rt', encoding='utf-8') as f:
			chunc = 100
			fin = ''
			while True:
				fragment = f.read(chunc)
				if not fragment:
					break

				fin += fragment
			print(fin)
			
	ВОТ ТАК МОЖНО ПОСТРОЧНО ИНФУ СОБИРАТЬ:
		with open('examp.txt', 'rt', encoding='utf-8') as f:
			fin = ''
			while True:
				line = f.readline()
				if not line:
					break

				fin += line
			print(fin)

		МЕНЯЕМ ПОЗИЦИЮ С ПОМОЩЬЮ seec()
			tell() - возращает текущее смещение от начала файла в байтах
			seec() - позволяет перейти к другому смещению в файле
			ну вот например 256-байтный бинарный файл
				fin = open('bfile', 'rb')
				fin.tell() # 0
				fin.seek(255)
				bdata = fin.read()
				len(bdata) # 1
				bdata[0] # 255
				также мы можем вызвать функцию seek(), передав ей второй аргумент seek(offset,origin)
				 если значение origin = 0(по умолчанию), вы сместитесь на offset байтов от начала
				 файла
				 если значение origin=1, вы сместитесь на offset байтов с текущей позиции
				 елси значение origin=2, вы сместитесь на offset байтов от конца файла 
				Благодаря этомйу можно считать последний байт разными способами
				 один байт перед концом файла:
					print(fin.seec(-1,2)) # покажет 1 байт перед концом файла
					
# ПРОВЕРЯЕМ СУЩЕСТВОВАНИЕ ФАЙЛА С ПОМОЩЬЮ ФУНКЦИИ exists()
	import os
	os.path.exists('название файла и txt не забывать, если нужно')
	
# ПРОВЕРЯЕМ ТИП С ПОМОЩЬЮ ФУНКЦИИ isfile()
	проверяет, файл ли находиться перед нами
		name = 'oops.txt'
		os.path.isfile(name) # True
	проверяет, папка ли это
		os.path.isdir(name)  # False
		
	Функция os.path.isabs() в Python проверяет, является ли переданный путь абсолютным.
	абсолютный путь - путь от корнегого каталога
	
# КОПИРУЕМ ФАЙЛЫ, ИСПОЛЬЗУЯ ФУНКЦИЮ copy()
	в этом примере файл oops.txt копируется в файл ohno.txt
		import shutil
		shutil.copy('ohno.txt', 'ohno.txt')
	функция shutil.move() копирует файл, а затем удаляет оригинал
	
# ИЗМЕНЯЕМ ИМЕНА ФАЙЛОВ С ПОМОЩЬЮ ФУНКЦИИ rename()
	import os
	os.rename('старое название','новое название')
	
# СОЗДАЕМ ССЫЛКИ С ПОМОЩЬЮ ФУНКЦИИ link() или symlink()
	link() - создает твердую ссылку
	symlink() - создает символьную ссылку (типо мягкой ссылки в линуксе)
		если такая ссылка, создана, то можете получить путь к настоящему файлу через нее 
		с помощью команды realpath()
			os.path.realpath('мягкая ссылка')
	символьная ссылка - сохраняет новое имя в своем собственном файле, позволяя вам получить 
	одновременно оба имени - оригинальное и новое
	islink() - проверяет, является ли файл символьной ссылкой
	os.link('файл', 'имя ссылки')
	os.symlink('файл', 'имя ссылки')
	
# ИЗМЕНЯЕМ РАЗРЕШЕНИЯ С ПОМОЩЬЮ ФУНКЦИИ chmod()
	такая штука есть в линуксе и по всей видимости тут она работает примерно так же
	
	например, для указания того, что файл oops.txt для чтения доступен только самому владельцу,
	нужно ввести слудующий код:
		os.chmod('oops.txt', 0o400)
	или по-другому можно записать то же самое, но нужно имортировать новый модуль
		import stat
		os.chmod('oops.txt', stat.S_IRUSR)
		
# ИЗМЕНЕНИЕ ВЛАДЕЛЬЦА ФАЙЛА С ПОМОЩЬЮ ФУНКЦИИ chown()
	мы можем изменить владельца или/и группу, указав ID пользователей(uid) и группы(gid)
		uid = 5
		gid = 22
		os.chmod('oops', uid, gid)
		
# УДАЛЯЕМ ФАЙЛ С ПОМОЩЬЮ remove()
	os.remove(oops.txt)
	
# КАТАЛОГИ(ПАПКИ)
	Контейнером для всех этих файлов и каталогов служит файловая система (еще ее называют томом)
	
# СОЗДАЕМ КАТАЛОГ С ПОМОЩЬЮ mkdir() и удаляем с помощью rmdir(). Смотрим сожержимое каталога с помощью listdir()
	os.mkdir('poems')
	os.path.exists('poems') # True
	os.mkdir('poems/aboba') # создали подкаталог
	os.listdir('poems') # ['aboba']
	os.rmdir('poems')

# ИЗМЕНЯЕМ ТЕКУБЩИЙ КАТАЛОГ С ПОМОЩЬЮ chdir() ПЕРЕЧЕСЛЯЕМ СОВПАДАЮЩИЕ ФАЙЛЫ, ИСПОЛЬЗУЯ ФУНКЦИЮ glob()
	* - совпадает со всем (вроде работает, как нормальная хуйня)
	? - любой 1 символ 
	[abc] - или или или 
	[!abc] - со всеми не или или или 
	
# PATHNAME
	да хуй знает, что это, тут путь к файлам какой-то создается странный
```	
 С ПОМОЩЬЮ ФУНКЦИИ abspath()
 os.path.abspath() получим путь 
```
# ПОСТРОЕНИЕ ПУТИ С ПОМОЩЬЮ ФУНКЦИИ os.path.join()
	import os
	win_file = os.path.join("eek", "urk")
	win_file = os.path.join(win_file, "short.txt") - короче так мы просто создали и объединили пути
	win_file # 'eek\\urk\\short.txt'
	
	# Создаём путь
	win_file = os.path.join("eek", "urk", "short.txt")

	# Создаём папки, если их нет
	os.makedirs(os.path.dirname(win_file), exist_ok=True)
	
	но у создания таких путей есть короч проблема. Проблема в том, что на уникс-подобных систумах 
	путь чуть по-другому выводится 

# МОДУЛЬ pathlib решает эту проблему
		from pathlib import Path
		file_path = Path('eek') / 'urk' / 'short.txt'
		file_path # WindowsPath('eek/urk/short.txt')
		print(file_path) # eek\urk\short.txt
		file_path.name # 'short.txt'
		file_path.suffix # '.txt'
		file_path.stem # 'short'
		
		from pathlib import Path

		file_path = Path('eek') / 'urk' / 'short.txt'

		# Создаём директории, если их нет
		file_path.parent.mkdir(parents=True, exist_ok=True)

		# Теперь можно безопасно открыть файл
		with open(file_path, 'wt', encoding='utf-8') as f: #а можно просто руками целый путь писать, что не удобно
			f.write("Теперь этот файл реально существует!")

# BytesIO и StringIO
	эти штуки работают одинаково, только  StringIO для текстовых данных (строк), а 
	BytesIO для бинарных данных (байтов)
	
# Вывести на экран список всех файлов из текущего каталога
	from pathlib import Path
	my_list = [f.name for f in Path('.').glob('*') if f.is_file()]
	print(my_list)
	тут прикол в том, что f - это объект вызывается, и f.name делает так, что нам ток имена записываются

# РОДИТЕЛЬСКОГО КАТАЛОГА другой способ просто
	from pathlib import Path

	parent_dir = Path.cwd().parent  # Получаем родительский каталог
	files = [f.name for f in parent_dir.iterdir() if f.is_file()]  # Только файлы

	print(files)
	Path.cwd().parent → Получает родительский каталог текущей папки.
	iterdir() → Перебирает все файлы и папки в родительском каталоге.
	if f.is_file() → Оставляет только файлы (папки исключаются).
	f.name → Выводит только имена файлов (без полного пути).

# в пайтоне короче можно получить доступ к данным процесса собственных программ
	import os
	# получим индефикатор процесса
	os.getpid() # 2716
	# получим текущую рабочкую папку запущенного интерпретатора
	os.getcwd() # 'C:\\Users\\aboob\\PycharmProjects\\вспоминаю_повторяю'
	# говорящие названия
	os.getuid()
	os.getgid()
	
# СОЗДАЕМ ПРОЦЕСС С ПОМОЩЬЮ МОДУЛЯ subprocess
	import subprocess
	да чет эта какая-то странная хуета
	
# СОЗДАЕМ ПРОЦЕСС С ПОМОЩЬЮ МОДУЛЯ multiprocessing
	import multiprocessing
	import os


	def whoami(what):
		print("Process %s says: %s" % (os.getpid(), what))


	if __name__ == "__main__":
		whoami("I'm the main program")
		for n in range(4):
			p = multiprocessing.Process(target=whoami,
			args=("I'm function %s" % n,))
			p.start()
```
ну хуй знает, смотри и радуйся что ли 

import multiprocessing
import time
import os

def whoami(name):
    print("I'm %s, in process %s" % (name, os.getpid()))

def loopy(name):
    whoami(name)
    start = 1
    stop = 1000000
    for num in range(start, stop):
        print(f"\tNumber {num} of {stop}. Honk!")
        time.sleep(1)

if __name__ == "__main__":
    whoami("main")
    p = multiprocessing.Process(target=loopy, args=("loopy",))
    p.start() # стартует
    time.sleep(10) # ждет 10 секунд
    p.terminate() # после 10 секунд заканчивает процесс
```
	
# КОНКУРЕНТНОСТЬ
	синхронность - одна вещь следует за дпугоой, как гусята, семенящие за родителями
	асинхронность - задачи независмы, как гуси, которые плавают в пруду.
```
ну короче, бывают сложности, тут вообще пиздабольством чел в книге занимается, говорит, что с
конкурентностьсю очереди помогают
```

# ОЧЕРЕДИ:
	очередь похожа на список: элементы добавляются с одного конца и удаляются с другого.
	Часто такой принцип называют FIFO(first in, first out - "первым пришел, первым ушел")
	больше ничего путного я не усвоил в этом тексте 

# ПРОЦЕССЫ 
	для соло компа модуль библиотеки multiprocessing
	содержит функцию Queue
```
import multiprocessing as mp


def washer(dishes, output):
    for dish in dishes:
        print(f'washing {dish} dish')
        output.put(dish)
    output.put(None)


def dryer(input):
    while True:
        dish = input.get()
        if dish is None:
            input.task_done()
            break
        print(f'Drying {dish} drying')
        input.task_done()


if __name__ == '__main__':
    dish_queue = mp.JoinableQueue()
    dryer_proc = mp.Process(target=dryer, args=(dish_queue,))
    dryer_proc.start()

    dishes = ['salsl', 'ofgof', 'ddgggf', 'aboba', 'dessert']
    washer(dishes, dish_queue)
    dish_queue.join()
    dryer_proc.join()
```
```
Конечно! Давай разберем код **подробно**, шаг за шагом. 

---

### **1. Импортируем библиотеку `multiprocessing`**
```python
import multiprocessing as mp
    ```
- `multiprocessing` позволяет выполнять **параллельные вычисления**, используя несколько процессов.
- `mp.JoinableQueue()` — это специальная очередь, которая позволяет отслеживать завершение задач.

---

### **2. Функция `washer()` (Моечная станция)**
```python
def washer(dishes, output):
    for dish in dishes:
        print(f'Washing {dish} dish')
        output.put(dish)  # Кладем тарелку в очередь
    output.put(None)  # Сигнал завершения
    ```
```
#### Как работает?  
- Перебираем список `dishes`, моем каждую тарелку и **кладем в очередь** `output.put(dish)`.  
- После того как все тарелки отправлены, кладем **`None`** в очередь, чтобы сообщить `dryer`, что работа закончена.

---

### **3. Функция `dryer()` (Сушильная станция)**
```python
def dryer(input):
    while True:
        dish = input.get()  # Берем тарелку из очереди
        if dish is None:
            input.task_done()  # Отмечаем как завершенную
            break  # Завершаем процесс
        print(f'Drying {dish} drying')
        input.task_done()  # Подтверждаем завершение обработки
```
#### Как работает?
- Бесконечный цикл **ждет тарелку** (`input.get()`).
- Если тарелка **не `None`**, сушит её и **отмечает как обработанную** (`input.task_done()`).
- Если в очередь пришло **`None`**, это сигнал, что мойка закончилась →  
  1. Отмечаем `None` как обработанный (`input.task_done()`).  
  2. **Прерываем цикл** (`break`).  

---

### **4. Главная часть (`if __name__ == '__main__':`)**
```python
if __name__ == '__main__':
    dish_queue = mp.JoinableQueue()  # Создаем очередь
    
    dryer_proc = mp.Process(target=dryer, args=(dish_queue,))  # Создаем процесс-сушилку
    dryer_proc.start()  # Запускаем сушилку

    dishes = ['salsl', 'ofgof', 'ddgggf', 'aboba', 'dessert']
    washer(dishes, dish_queue)  # Запускаем мойку, передаем тарелки в очередь

    dish_queue.join()  # Ждем, пока все задачи в очереди будут завершены
    dryer_proc.join()  # Дожидаемся завершения процесса сушилки
```
### Как работает?
1. **Создаем `dish_queue`** – очередь для передачи тарелок.
2. **Запускаем `dryer_proc`** – создаем и запускаем **отдельный процесс `dryer`**.
3. **Вызываем `washer(dishes, dish_queue)`** – процесс мойки отправляет тарелки в очередь.
4. **Ждем завершения всех задач** (`dish_queue.join()`).  
   - `join()` блокирует программу, пока **все задачи не будут обработаны**.
5. **Ждем завершения сушилки** (`dryer_proc.join()`).  
   - `join()` завершает процесс `dryer`, когда он закончит работу.

---

### **Как работает параллельность?**
✅ `washer()` и `dryer()` работают **одновременно** в разных процессах.  
✅ `washer()` моет тарелки и **отправляет** их в `dish_queue`.  
✅ `dryer()` **берет** тарелки из `dish_queue` и сушит их.  
✅ Когда `washer()` заканчивает, он **кладет `None`** в очередь, чтобы `dryer()` понял, что нужно завершиться.  
✅ `None` вызывает `break`, `dryer()` завершает работу, и программа успешно закрывается.

---

### **Вывод**
Твой код представляет собой **потокобезопасную обработку очереди** с параллельным выполнением мойки и сушки. 🚀 Отличный способ использовать `multiprocessing` для работы с очередями!

Если что-то осталось непонятным — спрашивай! 😊

## CSV
	некоторые имеют альтернативные разделители вместо запятой: самыми популярными являются '|' и '\t'
	некоторые имеют есейп-последовательности 
	некоторые имеют разные символы конца строк. в юникс '\n', на винде '\r\n'
	некоторые в перовй строке могут иметь название столбиков
	как записыать:
	import csv

	villains = [
		['doctor','no'],
		['rosa','kleb'],
		['Nikita','krytoy'],
		['Roman','geniy']
		]

	with open ('villains','wt', newline='') as f:
		csvout = csv.writer(f)
		csvout.writerows(villains)


### Считать обратно:
```
import csv


with open ('villains','rt') as f:
    cin = csv.reader(f)
    vil = [row for row in cin]

print(vil) # [['doctor', 'no'], ['rosa', 'kleb'], ['Nikita', 'krytoy'], ['Roman', 'geniy']]
```
# Считать можно и по-другому
```
import csv


with open ('villains','rt') as f:
    cin = csv.DictReader(f)
    vil = [row for row in cin]

print(vil) # [{'doctor': 'rosa', 'no': 'kleb'}, {'doctor': 'Nikita', 'no': 'krytoy'}, {'doctor': 'Roman', 'no': 'geniy
```
# Есть и еще один способ
```
import csv


with open ('villains','rt') as f:
    cin = csv.DictReader(f, fieldnames=['хуй','писька'])
    vil = [row for row in cin]

print(vil) # [{'хуй': 'doctor', 'писька': 'no'}, {'хуй': 'rosa', 'писька': 'kleb'}, {'хуй': 'Nikita', 'писька': 'krytoy'}, {'хуй': 'Roman', 'писька': 'geniy'}]
```
```
ну а записывать с названием столбцов так:

XWL формат - жто как на сайтах f12 жмаешь

html - формат гипертекстового языка разметка hypertext Markup Language
	это основной формат документов в интернете
```
# JSON ПОПУЛЯРНЫЙ ФОРМАТ ОБМЕНА ДАННЫМИ МЕЖДУ ПРОГРМАММАМИ
```
import json

menu = \
    {
        "breakfast": {
            "hours": "7-11",
            "items": {
                "breakfast burritos": "$6.00",
                "pancakes": "$4.00"
            }
        },

        "lunch": {
            "hours": "11-3",
            "items": {
                "hamburger": "$5.00"
            }
        },
        "dinner": {
            "hours": "3-10",
            "items": {
                "spaghetti": "$8.00"
            }
        }
    }
```
# кодируем структуру данных меню в строку json с помощью dumps()
    menu_json = json.dumps(menu)
    print(menu_json)

# обратно строку json в структуру данных
    menu2 = json.loads(menu_json)
    print(menu2)

```
pandas - библиотка, позволяет читать и записывать даные по множестве текстовыз и бинарных форматов
короче, крутая темка для работы с json, csv и т.д.
пример работы
import pandas as pd
import json
from io import StringIO

# Исходное меню
menu = {
    "breakfast": {
        "hours": "7-11",
        "items": {
            "breakfast burritos": "$6.00",
            "pancakes": "$4.00"
        }
    },
    "lunch": {
        "hours": "11-3",
        "items": {
            "hamburger": "$5.00"
        }
    },
    "dinner": {
        "hours": "3-10",
        "items": {
            "spaghetti": "$8.00"
        }
    }
}

# Преобразуем словарь в JSON-строку
menu_json = json.dumps(menu, indent=4)

# Используем StringIO для передачи JSON в pandas
menu_stream = StringIO(menu_json)

# Читаем JSON как DataFrame
menu_df = pd.read_json(menu_stream)
print("Исходный DataFrame:")
print(menu_df)

# Разворачиваем вложенные словари в отдельные колонки
df_normalized = pd.json_normalize(menu, sep="_")
print("\nРазвёрнутый DataFrame:")
print(df_normalized)


Документоориентированные базы данных
	это базы данныз формата NoSQL, которые хранят данные с разными полями
	
БАзы данных временных рядов
ГРафлвые базы данных


ГЛАВА 17 Данные в пространстве: сети

TCP/IP

Протоколы — это набор правил и стандартов, определяющих формат и порядок обмена 
	данными между устройствами в сети.
IP (Internet Protocol) — это сетевой протокол, обеспечивающий адресацию 
	и маршрутизацию пакетов данных в сети.
	
UDP (User Datagram Protocol) — это транспортный протокол, который передает данные в виде 
	независимых сообщений, называемых датаграммами. Он не гарантирует доставку, порядок получения 
	и целостность данных, но обеспечивает низкую задержку и минимальную нагрузку на сеть.
	
Датаграмма — это самостоятельный пакет данных, передаваемый по сети без установления соединения. 
	В отличие от потокового метода передачи, каждая датаграмма содержит заголовок с адресами 
	отправителя и получателя, но не гарантирует порядок доставки и целостность данных.
	
TCP (Transmission Control Protocol) — это транспортный протокол, обеспечивающий надежную, 
упорядоченную и гарантированную доставку данных. Он устанавливает соединение перед передачей, 
разбивает данные на сегменты, проверяет их целостность и обеспечивает повторную отправку 
потерянных пакетов.

Своя локальная машина будет иметь адрес 127.0.0.1 и имя localhost

Сокеты — это программные интерфейсы для обмена данными между устройствами в сети. 
Они позволяют приложениям устанавливать соединение, отправлять и получать данные по протоколам,
таким как TCP и UDP.


ГЛАВА 18 
РАСПУТЫВАЕМ ВСЕМРИНУЮ ПАУТИНУ

HTTP(протокол передачи гипертекста) - протокол для веб-клиентов и серверов для обмена запросами и ответами
HTML(гипертекстовый язык разметки) - формат для представления результатов
URL(удинообразный локатор ресурса) - способ уникально обозначить сервер и ресурс на этом сервере

в этих пунктахх пайтон збс
	клиенты для удаленного доступа 
	серверы предоставлляющие данные для сайтов веб-API
	веб-API и сервесы, позволяющие обмениваться данными другими способами, отличающимися от
	просматриваемых веб-страниц
	
ВЕБ-КЛИЕНТЫ
TCP/IP - протокол передачей/интернет протокол рассматривается более подробно
	перемещает байты между компьютерами
	
Всемирная паутна - это клиент-серверная система. Клиент делает запрос серверу: он
	открывает соединение TCP/IP, отправляет URL и дркгую информацию с помощью HTTP и получает ответ
	
браузер - самый известный веб-клиент 

Кэширование. Удаленный контент, который не меняется, должен быть созранен веб-клиентом и импользован
для того, чтобы не загружать его с сервера снова.

Сессии. Интернет-магазин должен запоминать содержимое вашей корзины 
Аутентификация. Сайты, которые требуют ваши имя пользователя и пароль, должны запоминать их, пока
вы авторезированы

ВЕБ СЕРВЕРЫ 
	классно их на пайтоне писать 
	в командной строке написать: python -m http.server
	если в браузере написать: http://localhost:8000
	ты зайдешь на свой сервер
	
	гит короче себе скачать можно
	https://bitly.com/pages/landing/branded-short-domains-powered-by-bitly?bsd=bit.ly
	
	и эту книгу себе скопировать через него нормально будет
	запустить команду git clone https://github.com/madscheme/introducing-python 
```